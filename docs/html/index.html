<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Mesh Editor</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2020</h1>
<h1 align="middle">Project 2: Mesh Editor</h1>
<h2 align="middle">Ziye Zhong, SID: 27055492</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p> In this project, I implemented several operations on geometric modeling. I started from building the Bezier curves using de Casteljau's algorithm. On the basis of it, I implemented the operation to build the Bezier surfaces. After that, I moved on to build 3-dimensional geometries by using triangle meshed and half-edge data structure. Calculating the area-weighted normal vectors at vertices makes the Phong shading possible, which provides better shading effect for the smooth surfaces. I also implemented edge flip and edge split. These two operations helps the final implementation of the mesh upsampling, which converts a coarse polygon mesh into a higher-resolution one.</p>

<br><br>

<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

<ul>
    <li><p> De Casteljau's algorithm is a recursive process to define a Bezier curve. It is done by first  connecting the control points with line segments, then inserting points using linear interpolation on each line segment, and repeating the process recursively until there is only one point left, which is located on the curve and helps define the curve.  It is implemented in BezierCurve::evaluateStep. The function takes a set of n control points, calculates the intermediate control point between every two using linear interpolation with the parameter t, and returns a set of n-1 control points. The function is called recursively until there is only one control point returned.</p></li>
    <li><p>The following images show the Bezier curve with 6 control points, with its each step / level of the evaluation from the original control points down to the final evaluated point.  </p></li>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="part1/01.png" align="middle" width="300px"/>
        <figcaption align="middle">Original Control Points</figcaption>
      </td>
      <td>
        <img src="part1/02.png" align="middle" width="300px"/>
        <figcaption align="middle">Step 1</figcaption>
      </td>
      <td>
        <img src="part1/03.png" align="middle" width="300px"/>
        <figcaption align="middle">Step 2</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="part1/04.png" align="middle" width="300px"/>
        <figcaption align="middle">Step 3</figcaption>
      </td>
      <td>
        <img src="part1/05.png" align="middle" width="300px"/>
        <figcaption align="middle">Step 4</figcaption>
      </td>
      <td>
        <img src="part1/06.png" align="middle" width="300px"/>
        <figcaption align="middle">Final Step</figcaption>
      </td>
    </tr>
  </table>
</div>

<li><p>The below images show another Bezier curve with the original control points at different positions.</p></li>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="part1/07.png" align="middle" width="300px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="part1/08.png" align="middle" width="300px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="part1/09.png" align="middle" width="300px"/>
        <figcaption align="middle"></figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

</ul>

<br>

<h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>
<ul>
    <li><p>Bezier surfaces involve applying de Casteljau's algorithm in two dimensions. It first computes with each row of control points with the parameter u , and gets the point lie on the Bezier curve of each row. With a column of these points, it then computes the final point on the Bezier surface with the parameter u. It is implemented in three step. First, I implemented BezierPatch::evaluateStep, which is similar to the one in Part 1, except that it takes in a vector of 3D points, and returns a new vector of 3D points. Then I implemented BezierPatch::evaluate1D, which recursively calls BezierPatch::evaluateStep until there is only one point left, which is on the Bezier curve. Finally, I implemented BezierPatch::evaluate, which calls BezierPatch::evaluate1D with each row of control points, added the returned points into a new vector, and calls BezierPatch::evaluate1D again with the new vector to get the final point on the surface.</p></li>
    
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="part2/01.png" align="middle" width="700px"/>
            <figcaption align="middle">bez/teapot.bez</figcaption>
          </td>
        </tr>
      </table>
    </div>
</ul>

<br><br>

<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 3: Average normals for half-edge meshes</h3>
<ul>
    <li><p>To implement Vertex::normal, I first created a Vector3D normal at (0, 0, 0) to store the sum of the weighted normal of each triangles incident to the vertex. Then I iterate though the half edges of the vertex. For each half edge, I calculated the weighted normal of its corresponding triangle, with a helper function weightNorm. Then the returned Vector3D is added to normal. Finally, normal.unit() is returned.</p></li>
    <li><p>The below images show the difference between the flat shading and the Phong shading.</p></li>
    
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="part3/01.png" align="middle" width="400px"/>
            <figcaption align="middle">Flat Shading</figcaption>
          </td>
          <td>
            <img src="part3/02.png" align="middle" width="400px"/>
            <figcaption align="middle">Phong Shading</figcaption>
          </td>
        </tr>
        <br>
      </table>
    </div>

<br>

<h3 align="middle">Part 4: Half-edge flip</h3>
<ul>
    <li><p>Before implementing, I drew two triangles abc and cbd, sharing the edge cb and having arrows as the half edges, on my scratch paper. I listed out all the elements involved, including 4 vertices, 5 edges, 2 faces, and 10 half edges. I then drew the triangles after edge flip. When I started to implement the function, I first identified the two half edges and the two faces from the input. If either of the faces is at the boundary, the function returns the input directly. If not, then, I identified the rest of half edges of the triangles along with their twins, the vertices, and the edges, according to the first drawing. After that, I assigned the new elements(next, twin, vertex, edge, face) to each half edges according to the two triangles after flipped. Finally, I assigned new half edges to the vertices, edges, and two faces, and then return the edge.</p></li>
    <li><p>The below images show a mesh before and after some edge flips.</p></li>
    
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="part4/01.png" align="middle" width="400px"/>
            <figcaption align="middle">Before Egde Flips</figcaption>
          </td>
          <td>
            <img src="part4/02.png" align="middle" width="400px"/>
            <figcaption align="middle">After Edge Flips</figcaption>
          </td>
        </tr>
        <br>
      </table>
    </div>
    
    <li><p>When I first implemented the function, after I flipped the same edge for a few times, one of its half edge’s face would miss an adjacent triangle next to it. This created a hole in the teapot. After checking the edge, I found that it was because I didn’t assign the edges’ twins with the new elements. The edges’ twins were also affected by the flip, and this caused the missing of adjacent face. </p></li></ul>

<br>

<h3 align="middle">Part 5: Half-edge split</h3>
<ul>
    <li><p>Implementing the edge split is similar to implementing the edge flip, except that it requires adding some new mesh elements. I first draw the two triangle abc and cbd with the arrow. I listed out the 4 vertices, 5 edges, 2 faces, and 10 half edges as in the edge flip. I also drew the triangles after the edge split at m, listed out the newly added 1 vertex, 3 edges, 2 faces, and 6 half edges. When starting to implement, I first identified the two half edges and the two faces from the input, to check if they are on the boundary. If they are, the function returns immediately. If not, I identified the rest of the half edges, vertices, and the edges. Then I added the new elements according to the list. The new vertex m is at the position of (b + c) / 2. After that, I assigned next, twin, vertex, edge, and face, to the total 16 half edges, based on the second drawing. Finally, I assigned new half edges to the 5 vertices, 8 edges, and 4 faces, and then return the vertex m.</p></li>
    <li><p>The below images show a mesh before and after some edge splits.</p></li>
    
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="part5/01.png" align="middle" width="400px"/>
            <figcaption align="middle">Before Egde Splits</figcaption>
          </td>
          <td>
            <img src="part5/02.png" align="middle" width="400px"/>
            <figcaption align="middle">After Edge Splits</figcaption>
          </td>
        </tr>
        <br>
      </table>
    </div>

    <li><p>The below images show a mesh before and after a combination of both edge splits and edge flips.</p></li></ul>

    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="part5/01.png" align="middle" width="400px"/>
            <figcaption align="middle">Before Egde Splits</figcaption>
          </td>
          <td>
            <img src="part5/03.png" align="middle" width="400px"/>
            <figcaption align="middle">After Edge Flips and Splits</figcaption>
          </td>
        </tr>
        <br>
      </table>
    </div>

<br>
    
<h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>
<ul>
    <li><p> Implementing the loop subdivision involves five steps. First I iterate though all the vertices, to set  Vertex::isNew to false, and to calculate the new position of these vertices, stored in each vertex’s newPosition. Secondly, I iterate through all the edges, to set Edge::isNew to false, and to calculate the position of the new vertex’s position on the edge, stored in Edge::newPosition. In the edge split function, I also need to set the Vertex::isNew of the newly created vertex to true, the Edge::isNew of the newly created edges to true, and the Edge::isNew of the spited edges to false. Thirdly, I iterate through all the edges. For the edges connecting two old vertices, split the edge, set the newPosition of the new vertex to the one stored in the edge. After that, I iterate the edges again, for the new edges connecting one new vertex and one old vertex, flip the edge. Finally, set all the vertices’ positions to the their newPosition. To debug, I first commented the fourth and fifth steps, until the third one appears to be correct. Then I commented only the last step, until the fourth steps looks correct. I finally uncomment the last step, so that I can check if the first and second steps run correctly. </p></li>
    <li><p> In the dae/cube.dae, after several times of loop subdivisions, the sharp edges are smoothed out, but there are still corners (fig.2). Then I pre-splitted the edges on the cube’s surfaces (fig.3), after after several times of loop subdivisions, the corners are also rounded. The entire geometry became smoother. </p></li>
    
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="part6/01.png" align="middle" width="400px"/>
            <figcaption align="middle">Fig.1</figcaption>
          </td>
          <td>
            <img src="part6/02.png" align="middle" width="400px"/>
            <figcaption align="middle">Fig.2</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="part6/03.png" align="middle" width="400px"/>
            <figcaption align="middle">Fig.3</figcaption>
          </td>
          <td>
            <img src="part6/04.png" align="middle" width="400px"/>
            <figcaption align="middle">Fig.4</figcaption>
          </td>
        </tr>
      </table>
    </div>

    
    <li><p>Also, before pre-splitting the cube, the cube becomes slightly asymmetric after upsample. This is because of that there was only one edge to split on each face, which leads to the asymmetry.  Pre-splitting the cube would help the cube become more symmetric because pre-splitting creates a cross of edges on the faces. This symmetric patterns makes the upsampled cube symmetric. </p></li></ul>


</body>
</html>
